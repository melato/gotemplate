gotemplate provides a small Go command-line program that executes templates,
using the text/template package from the Go standard library.

# Goals
gotemplate is designed to facilitate producing markdown documentation for code.
I created it so that I can include working code samples that can be easily tested,
instead of copying them by hand to a README file.

It is not suitable for producing HTML.
An HTML generator should have more features, such as layouts (themes),
and also use html/template instead of text/template.

# Design
Executing Go templates requires three main inputs:

## A Function Map
A Function map (template.FuncMap) provides custom functions.
The gotemplate does not define any custom functions, when used as a library.

The gotemplate module defines the *file* function that reads a file. 
The library does not add it automatically to the templates, but the main executable does.
This is provided as an example, but it is also useful for including code samples
in documentation.  If you want more functions, write your own.

## The templates
These are the files parsed into text/template.Template.
The function map should be defined before parsing the templates,
because it is used during parsing.

## The data model
This is the data passed to the Template.Execute().
Gotemplate uses a *map[any]any* data structure.
The map is built by parsing yaml or json files, and
by command-line arguments.

# Example
This README.md file was generated by running the script:

{{template "file.tpl" "readme.sh"}}

Using the templates:

- [doc/common/file.tpl](doc/common/file.tpl)
- [doc/README.tpl](doc/README.tpl)

It can also be generated by running the alternate script:

{{template "file.tpl" "build.sh"}}

which uses the configuration file:

{{template "file.tpl" "doc/build.yaml"}}

This script could generate multiple output files, but we use just one.

# main
The main executable also serves as an example about how to add custom functions to the templates:

{{template "file.tpl" "main/gotemplate.go"}}

## exec
The *exec* command uses command line arguments to specify everything.  It:
- parses a set of associated templates
- builds a data model
- executes one template and produces one output file

## build
The *build* command uses yaml configuration file to specify most parameters.
The configuration file specifies:
- a set of common templates
- a map to uses as the data model
- an input directory of templates.

Each input template is parsed after cloning the common templates.
Therefore it has access to the common templates, but not to other input templates.

## help
The *help* subcommands are meant to provide documentation for the template functions.
