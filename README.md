gotemplate provides a small Go command-line program that executes templates,
using the text/template package from the Go standard library.

It is also a library that can be extended in order to add custom functions to the templates.

# Goals
gotemplate is designed to facilitate producing markdown documentation for code.
I created it so that I can include working code samples that can be easily tested,
instead of copying them by hand to a README file.

It is not suitable for producing HTML.
An HTML generator should use html/template instead of text/template,
and also have more features, such as layouts (themes).

# Design
Executing Go templates requires three components:
- FuncMap
- Templates
- Data Model

When you use gotemplate as a library, you can provide functions, templates, and data
in the executable.  When you run it, you can add data and template files from the command line,
or from a configuration file.

## Function Map
A Function map (template.FuncMap) provides custom functions.
The FuncMap is defined before parsing any templates,
because it is used during parsing.

Functions are available in all associated templates.

The gotemplate executable defines just one *file* function that reads a file. 
This is provided as an example, but it is also useful for including code samples
in documentation.
If you want more functions, write your own functions, customized for your templates.

## Templates
These are the files parsed into text/template.Template.

A template may produce an output file, or it may be used by another template.

## Data model
This is the data passed to Template.Execute().
Gotemplate uses a *map[any]any* data structure for the templates that it executes directly.
The map is built by parsing yaml or json files, 
by command-line arguments, and by Go code.

When a template uses another template, it can pass it a single argument that serves as its data model.
If an included template needs access to both the including template's data model and to additional arguments,
you can use a custom function that aggregates these into a custom struct, from which the included template
can extract what it needs.

Functions can also provide data for the templates.
They can read data from a file, provide data compiled in the application, etc.

# Example
This README.md file was generated by running the script:

**readme.sh**
```
#!/bin/sh

# generates README.md

gotemplate exec -o README.md -t README.tpl doc/common/*.tpl doc/*.tpl 

```


Using the templates:

- [doc/common/file.tpl](doc/common/file.tpl)
- [doc/README.tpl](doc/README.tpl)

It can also be generated by running the alternate script:

**build.sh**
```
#!/bin/sh

# generates README.md

gotemplate build -c doc/build.yaml -o .

```


which uses the configuration file:

**doc/build.yaml**
```
input_dir: ./
input_ext: .tpl
output_ext: .md 
templates:
- dir: common
  patterns:
  - "*.tpl"

```


This script could generate multiple output files, but we use just one.

# main
The main executable also serves as an example about how to add custom functions to the templates:

**main/gotemplate.go**
```
package main

import (
	"fmt"

	"melato.org/command"
	"melato.org/gotemplate"
	"melato.org/gotemplate/cli"
	"melato.org/gotemplate/funcs"
)

var version string

func main() {
	var config gotemplate.Config
	funcs.AddFuncs(&config)
	cmd := cli.Command(&config)
	cmd.Command("version").NoConfig().RunFunc(func() {
		fmt.Printf("%s\n", version)
	}).Short("print version")
	command.Main(cmd)
}

```


## commands
### exec
The *exec* command produces one output file from one input template. 
It uses command line arguments to specify everything.  It:
- parses a set of associated templates
- builds a data model
- executes one of the templates to produces the output

### build
The *build* command uses a yaml configuration file to specify most parameters.
The configuration file specifies:
- sets of common templates
- a map to uses as the data model
- an input directory of templates.
- input and output file extensions

Each input template is parsed after cloning the common templates.
Therefore it has access to the common templates, but not to other input templates.

### help
The *help* subcommands provide documentation for the template components that are available.
